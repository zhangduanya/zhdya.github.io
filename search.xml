<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CMDB项目需求分析]]></title>
    <url>%2F2019%2F03%2F03%2F4%E3%80%81Windows%E4%B8%8B%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[一、windows中收集硬件信息为了收集运行Windows操作系统的服务器的硬件信息，我们需要编写一个专门的脚本。 在Pycharm的Client目录下的plugins包中，新建一个windows包，然后创建一个sys_info.py文件，写入下面的代码： ==&lt;如下打印data的语句，是为了调试查看输出，可以去掉&gt;==123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019-3-2 16:41# @Author : zhdya@zhdya.cn# @File : sys_info.pyimport platformimport win32comimport wmi&quot;&quot;&quot;本模块基于windows操作系统，依赖wmi和win32com库，需要提前使用pip进行安装，或者下载安装包手动安装。&quot;&quot;&quot;def collect(): data = &#123; &apos;os_type&apos;: platform.system(), &apos;os_release&apos;: &quot;%s %s %s &quot; % (platform.release(), platform.architecture()[0], platform.version()), &apos;os_distribution&apos;: &apos;Microsoft&apos;, &apos;asset_type&apos;: &apos;server&apos; &#125; # 分别获取各种硬件信息 win32obj = Win32Info() data.update(win32obj.get_cpu_info()) data.update(win32obj.get_ram_info()) data.update(win32obj.get_motherboard_info()) data.update(win32obj.get_disk_info()) data.update(win32obj.get_nic_info()) # 最后返回一个数据字典 print(&quot;data11&quot;, data) return dataclass Win32Info(object): def __init__(self): # 固定用法，更多内容请参考模块说明 self.wmi_obj = wmi.WMI() self.wmi_service_obj = win32com.client.Dispatch(&quot;WbemScripting.SWbemLocator&quot;) self.wmi_service_connector = self.wmi_service_obj.ConnectServer(&quot;.&quot;, &quot;root\cimv2&quot;) def get_cpu_info(self): &quot;&quot;&quot; 获取CPU的相关数据，这里只采集了三个数据，实际有更多，请自行选择需要的数据 :return: &quot;&quot;&quot; data = &#123;&#125; cpu_lists = self.wmi_obj.Win32_Processor() cpu_core_count = 0 for cpu in cpu_lists: cpu_core_count += cpu.NumberOfCores cpu_model = cpu_lists[0].Name # CPU型号（所有的CPU型号都是一样的） data[&quot;cpu_count&quot;] = len(cpu_lists) # CPU个数 data[&quot;cpu_model&quot;] = cpu_model data[&quot;cpu_core_count&quot;] = cpu_core_count # CPU总的核数 print(&quot;data22&quot;, data) return data def get_ram_info(self): &quot;&quot;&quot; 收集内存信息 :return: &quot;&quot;&quot; data = [] # 这个模块用SQL语言获取数据 ram_collections = self.wmi_service_connector.ExecQuery(&quot;Select * from Win32_PhysicalMemory&quot;) for item in ram_collections: # 主机中存在很多根内存，要循环所有的内存数据 ram_size = int(int(item.Capacity) / (1024**3)) # 转换内存单位为GB item_data = &#123; &quot;slot&quot;: item.DeviceLocator.strip(), &quot;capacity&quot;: ram_size, &quot;model&quot;: item.Caption, &quot;manufacturer&quot;: item.Manufacturer, &quot;sn&quot;: item. SerialNumber, &#125; data.append(item_data) # 将每条内存的信息，添加到一个列表里 print(&quot;data33&quot;, data) return &#123;&quot;ram&quot;: data&#125; # 再对data列表封装一层，返回一个字典，方便上级方法的调用 def get_motherboard_info(self): &quot;&quot;&quot; 获取主板信息 :return: &quot;&quot;&quot; computer_info = self.wmi_obj.Win32_ComputerSystem()[0] system_info = self.wmi_obj.Win32_OperatingSystem()[0] data = dict() data[&apos;manufacturer&apos;] = computer_info.Manufacturer data[&apos;model&apos;] = computer_info.Model data[&apos;wake_up_type&apos;] = computer_info.WakeUpType data[&apos;sn&apos;] = system_info.SerialNumber print(&quot;data44&quot;, data) return data def get_disk_info(self): &quot;&quot;&quot; 硬盘信息 :return: &quot;&quot;&quot; data = [] for disk in self.wmi_obj.Win32_DiskDrive(): # 每块硬盘都要获取相应信息 item_data = dict() iface_choices = [&quot;SAS&quot;, &quot;SCSI&quot;, &quot;SATA&quot;, &quot;SSD&quot;] for iface in iface_choices: if iface in disk.Model: item_data[&apos;iface_type&apos;] = iface break else: item_data[&apos;iface_type&apos;] = &apos;unknown&apos; item_data[&apos;slot&apos;] = disk.Index item_data[&apos;sn&apos;] = disk.SerialNumber item_data[&apos;model&apos;] = disk.Model item_data[&apos;manufacturer&apos;] = disk.Manufacturer item_data[&apos;capacity&apos;] = int(int(disk.Size) / (1024**3)) data.append(item_data) print(&quot;data55&quot;, data) return &#123;&apos;physical_disk_driver&apos;: data&#125; def get_nic_info(self): &quot;&quot;&quot; 网卡信息 :return: &quot;&quot;&quot; data = [] for nic in self.wmi_obj.Win32_NetworkAdapterConfiguration(): if nic.MACAddress is not None: item_data = dict() item_data[&apos;mac&apos;] = nic.MACAddress item_data[&apos;model&apos;] = nic.Caption item_data[&apos;name&apos;] = nic.Index if nic.IPAddress is not None: item_data[&apos;ip_address&apos;] = nic.IPAddress[0] item_data[&apos;net_mask&apos;] = nic.IPSubnet else: item_data[&apos;ip_address&apos;] = &apos;&apos; item_data[&apos;net_mask&apos;] = &apos;&apos; data.append(item_data) print(&quot;data66&quot;, data) return &#123;&apos;nic&apos;: data&#125;if __name__ == &quot;__main__&quot;: # 测试代码(仅限于在当前页面运行获取本机的信息） dic = collect() print(dic) windows中没有方便的命令可以获取硬件信息，但是有额外的模块可以帮助我们实现目的，这个模块叫做wmi。可以使用1pip install wmi 的方式安装，当前版本是1.4.9。但是wmi安装后，import wmi依然会出错，因为它依赖一个叫做win32com的模块。 我们依然可以通过1pip install pypiwin32 来安装win32com模块，但是不幸的是，据反映，有些机器无法通过pip成功安装。所以，这里我在github中提供了一个手动安装包==pywin32-220.win-amd64-py3.5(配合wmi模块，获取主机信息的模块).exe==，方便大家。12链接：https://pan.baidu.com/s/14ZUKPJnmlwuUHsYLUUApKg 提取码：nq5i 依赖包的问题解决后，我们来看一下==sys_info.py==脚本的代码。 核心在于collect()方法！ 该方法首先通过platform模块获取平台的信息，然后保存到一个data字典中。 然后创建一个Win32Info对象，并调用win32的各种功能方法，分别获取CPU、RAM、主板、硬盘和网卡的信息。 类Win32Info是我们编写的封装了具体数据收集逻辑的类； 该类中有很多方法，每个方法针对一项数据； 其中对Win32模块的调用方式是固定的，有兴趣的可以自行学习这个模块的官方文档 每一类的数据收集完成后都会作为一个新的子字典，update到开始的data字典中，最终形成完整的信息字典。 最后在脚本末尾有一个测试入口。 整个脚本的代码其实很简单，我们只要将Win32的方法调用当作透明的空气，剩下的不过就是将获得的数据，按照我们指定的格式打包成一个数据字典。 ==强调：数据字典的格式和键值是非常重要的，是预设的，不可以随意改变！== 二、信息收集测试单独运行一下该脚本（注意不是运行CMDB项目），查看一下生成的数据：1234567data22 &#123;&apos;cpu_core_count&apos;: 4, &apos;cpu_count&apos;: 1, &apos;cpu_model&apos;: &apos;Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz&apos;&#125;data33 [&#123;&apos;slot&apos;: &apos;DIMM A&apos;, &apos;capacity&apos;: 8, &apos;manufacturer&apos;: &apos;802C0000802C&apos;, &apos;model&apos;: &apos;物理内存&apos;, &apos;sn&apos;: &apos;1B458788&apos;&#125;]data44 &#123;&apos;sn&apos;: &apos;00330-80000-00000-AA069&apos;, &apos;manufacturer&apos;: &apos;Dell Inc.&apos;, &apos;model&apos;: &apos;Latitude 5480&apos;, &apos;wake_up_type&apos;: 6&#125;data55 [&#123;&apos;slot&apos;: 0, &apos;capacity&apos;: 238, &apos;manufacturer&apos;: &apos;(标准磁盘驱动器)&apos;, &apos;model&apos;: &apos;SAMSUNG SSD PM871b M.2 2280 256GB&apos;, &apos;iface_type&apos;: &apos;SSD&apos;, &apos;sn&apos;: &apos; S3U0NY0K244546&apos;&#125;]data66 [&#123;&apos;name&apos;: 1, &apos;mac&apos;: &apos;00:50:56:C0:00:08&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000001] VMware Virtual Ethernet Adapter for VMnet8&apos;, &apos;ip_address&apos;: &apos;192.168.171.1&apos;&#125;, &#123;&apos;name&apos;: 2, &apos;mac&apos;: &apos;00:50:56:C0:00:01&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000002] VMware Virtual Ethernet Adapter for VMnet1&apos;, &apos;ip_address&apos;: &apos;192.168.209.1&apos;&#125;, &#123;&apos;name&apos;: 3, &apos;mac&apos;: &apos;00:FF:E2:52:B5:09&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000003] TAP-Windows Adapter V9&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 4, &apos;mac&apos;: &apos;10:65:30:11:8A:8A&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000004] Intel(R) Ethernet Connection (5) I219-LM&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 5, &apos;mac&apos;: &apos;68:EC:C5:86:F1:DC&apos;, &apos;net_mask&apos;: (&apos;255.255.240.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000005] Intel(R) Dual Band Wireless-AC 8265&apos;, &apos;ip_address&apos;: &apos;10.10.7.26&apos;&#125;, &#123;&apos;name&apos;: 6, &apos;mac&apos;: &apos;68:EC:C5:86:F1:DD&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000006] Microsoft Wi-Fi Direct Virtual Adapter&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 7, &apos;mac&apos;: &apos;68:EC:C5:86:F1:E0&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000007] Bluetooth Device (Personal Area Network)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 13, &apos;mac&apos;: &apos;14:74:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000013] WAN Miniport (IP)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 14, &apos;mac&apos;: &apos;14:FC:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000014] WAN Miniport (IPv6)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 15, &apos;mac&apos;: &apos;16:0F:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000015] WAN Miniport (Network Monitor)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 16, &apos;mac&apos;: &apos;6A:EC:C5:86:F1:DC&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000016] Microsoft Wi-Fi Direct Virtual Adapter&apos;, &apos;ip_address&apos;: &apos;192.168.137.1&apos;&#125;]data11 &#123;&apos;manufacturer&apos;: &apos;Dell Inc.&apos;, &apos;model&apos;: &apos;Latitude 5480&apos;, &apos;cpu_core_count&apos;: 4, &apos;os_distribution&apos;: &apos;Microsoft&apos;, &apos;asset_type&apos;: &apos;server&apos;, &apos;cpu_model&apos;: &apos;Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz&apos;, &apos;nic&apos;: [&#123;&apos;name&apos;: 1, &apos;mac&apos;: &apos;00:50:56:C0:00:08&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000001] VMware Virtual Ethernet Adapter for VMnet8&apos;, &apos;ip_address&apos;: &apos;192.168.171.1&apos;&#125;, &#123;&apos;name&apos;: 2, &apos;mac&apos;: &apos;00:50:56:C0:00:01&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000002] VMware Virtual Ethernet Adapter for VMnet1&apos;, &apos;ip_address&apos;: &apos;192.168.209.1&apos;&#125;, &#123;&apos;name&apos;: 3, &apos;mac&apos;: &apos;00:FF:E2:52:B5:09&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000003] TAP-Windows Adapter V9&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 4, &apos;mac&apos;: &apos;10:65:30:11:8A:8A&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000004] Intel(R) Ethernet Connection (5) I219-LM&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 5, &apos;mac&apos;: &apos;68:EC:C5:86:F1:DC&apos;, &apos;net_mask&apos;: (&apos;255.255.240.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000005] Intel(R) Dual Band Wireless-AC 8265&apos;, &apos;ip_address&apos;: &apos;10.10.7.26&apos;&#125;, &#123;&apos;name&apos;: 6, &apos;mac&apos;: &apos;68:EC:C5:86:F1:DD&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000006] Microsoft Wi-Fi Direct Virtual Adapter&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 7, &apos;mac&apos;: &apos;68:EC:C5:86:F1:E0&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000007] Bluetooth Device (Personal Area Network)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 13, &apos;mac&apos;: &apos;14:74:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000013] WAN Miniport (IP)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 14, &apos;mac&apos;: &apos;14:FC:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000014] WAN Miniport (IPv6)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 15, &apos;mac&apos;: &apos;16:0F:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000015] WAN Miniport (Network Monitor)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 16, &apos;mac&apos;: &apos;6A:EC:C5:86:F1:DC&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000016] Microsoft Wi-Fi Direct Virtual Adapter&apos;, &apos;ip_address&apos;: &apos;192.168.137.1&apos;&#125;], &apos;physical_disk_driver&apos;: [&#123;&apos;slot&apos;: 0, &apos;capacity&apos;: 238, &apos;manufacturer&apos;: &apos;(标准磁盘驱动器)&apos;, &apos;model&apos;: &apos;SAMSUNG SSD PM871b M.2 2280 256GB&apos;, &apos;iface_type&apos;: &apos;SSD&apos;, &apos;sn&apos;: &apos; S3U0NY0K244546&apos;&#125;], &apos;wake_up_type&apos;: 6, &apos;sn&apos;: &apos;00330-80000-00000-AA069&apos;, &apos;cpu_count&apos;: 1, &apos;os_release&apos;: &apos; 64bit 10.0.17763 &apos;, &apos;ram&apos;: [&#123;&apos;slot&apos;: &apos;DIMM A&apos;, &apos;capacity&apos;: 8, &apos;manufacturer&apos;: &apos;802C0000802C&apos;, &apos;model&apos;: &apos;物理内存&apos;, &apos;sn&apos;: &apos;1B458788&apos;&#125;], &apos;os_type&apos;: &apos;Windows&apos;&#125;&#123;&apos;manufacturer&apos;: &apos;Dell Inc.&apos;, &apos;model&apos;: &apos;Latitude 5480&apos;, &apos;cpu_core_count&apos;: 4, &apos;os_distribution&apos;: &apos;Microsoft&apos;, &apos;asset_type&apos;: &apos;server&apos;, &apos;cpu_model&apos;: &apos;Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz&apos;, &apos;nic&apos;: [&#123;&apos;name&apos;: 1, &apos;mac&apos;: &apos;00:50:56:C0:00:08&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000001] VMware Virtual Ethernet Adapter for VMnet8&apos;, &apos;ip_address&apos;: &apos;192.168.171.1&apos;&#125;, &#123;&apos;name&apos;: 2, &apos;mac&apos;: &apos;00:50:56:C0:00:01&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000002] VMware Virtual Ethernet Adapter for VMnet1&apos;, &apos;ip_address&apos;: &apos;192.168.209.1&apos;&#125;, &#123;&apos;name&apos;: 3, &apos;mac&apos;: &apos;00:FF:E2:52:B5:09&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000003] TAP-Windows Adapter V9&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 4, &apos;mac&apos;: &apos;10:65:30:11:8A:8A&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000004] Intel(R) Ethernet Connection (5) I219-LM&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 5, &apos;mac&apos;: &apos;68:EC:C5:86:F1:DC&apos;, &apos;net_mask&apos;: (&apos;255.255.240.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000005] Intel(R) Dual Band Wireless-AC 8265&apos;, &apos;ip_address&apos;: &apos;10.10.7.26&apos;&#125;, &#123;&apos;name&apos;: 6, &apos;mac&apos;: &apos;68:EC:C5:86:F1:DD&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000006] Microsoft Wi-Fi Direct Virtual Adapter&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 7, &apos;mac&apos;: &apos;68:EC:C5:86:F1:E0&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000007] Bluetooth Device (Personal Area Network)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 13, &apos;mac&apos;: &apos;14:74:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000013] WAN Miniport (IP)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 14, &apos;mac&apos;: &apos;14:FC:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000014] WAN Miniport (IPv6)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 15, &apos;mac&apos;: &apos;16:0F:20:52:41:53&apos;, &apos;net_mask&apos;: &apos;&apos;, &apos;model&apos;: &apos;[00000015] WAN Miniport (Network Monitor)&apos;, &apos;ip_address&apos;: &apos;&apos;&#125;, &#123;&apos;name&apos;: 16, &apos;mac&apos;: &apos;6A:EC:C5:86:F1:DC&apos;, &apos;net_mask&apos;: (&apos;255.255.255.0&apos;, &apos;64&apos;), &apos;model&apos;: &apos;[00000016] Microsoft Wi-Fi Direct Virtual Adapter&apos;, &apos;ip_address&apos;: &apos;192.168.137.1&apos;&#125;], &apos;physical_disk_driver&apos;: [&#123;&apos;slot&apos;: 0, &apos;capacity&apos;: 238, &apos;manufacturer&apos;: &apos;(标准磁盘驱动器)&apos;, &apos;model&apos;: &apos;SAMSUNG SSD PM871b M.2 2280 256GB&apos;, &apos;iface_type&apos;: &apos;SSD&apos;, &apos;sn&apos;: &apos; S3U0NY0K244546&apos;&#125;], &apos;wake_up_type&apos;: 6, &apos;sn&apos;: &apos;00330-80000-00000-AA069&apos;, &apos;cpu_count&apos;: 1, &apos;os_release&apos;: &apos; 64bit 10.0.17763 &apos;, &apos;ram&apos;: [&#123;&apos;slot&apos;: &apos;DIMM A&apos;, &apos;capacity&apos;: 8, &apos;manufacturer&apos;: &apos;802C0000802C&apos;, &apos;model&apos;: &apos;物理内存&apos;, &apos;sn&apos;: &apos;1B458788&apos;&#125;], &apos;os_type&apos;: &apos;Windows&apos;&#125; 上面的信息包含操作系统、主板、CPU、内存、硬盘、网卡等各种信息。可以看到我有1条内存，1块SSD硬盘，以及4块网卡。四块网卡有出现mac地址相同的情况，因为那是虚拟机的。 你自己的数据和我的肯定不一样，但是数据格式和键值必须一样，我们后面自动分析数据、填充数据，都依靠这个固定格式的数据字典。 通过测试我们发现数据可以收集到了，那么再测试一下数据能否正常发送到服务器。 三、数据发送测试由于我这里采用了Linux虚拟机作为测试用例，我们的Django服务器就不能再运行在127.0.0.1:8000上面了。 查看一下当前机器的IP，发现是192.168.1.100，修改项目的settings.py文件，将ALLOWED_HOSTS修改如下： 1ALLOWED_HOSTS = [&quot;*&quot;] 这表示接收所有同一局域网内的网络访问。 然后以0.0.0.0:8000的参数启动CMDB，表示对局域网内所有ip开放服务。 回到客户端，进入Client/bin目录，运行1python main.py report_data 可以看到如下结果：1234567正在将数据发送至： [http://10.10.7.26:8000/assets/report/] ......handler_data_encode--&gt;&gt; b&apos;asset_data=%7B%22cpu_core_count%22%3A+4%2C+%22cpu_model%22%3A+%22Intel%28R%29+Core%28TM%29+i5-7300HQ+CPU+%40+2.50GHz%22%2C+%22wake_up...&lt;中间信息省略&gt;...71b+M.2+2280+256GB%22%2C+%22capacity%22%3A+238%7D%5D%2C+%22cpu_count%22%3A+1%2C+%22os_distribution%22%3A+%22Microsoft%22%2C+%22asset_type%22%3A+%22server%22%7D&apos;?[31;1m发送失败，HTTP Error 404: Not Found?[0m日志记录成功！ 这是一个404错误，表示服务器地址没找到，这是因为我们还没有为Django编写接收数据的视图和路由。 这时，打开log目录下的日志文件，内容如下：1发送时间：2019-03-03 10:49:26 服务器地址：http://10.10.7.26:8000/assets/report/ 返回结果：发送失败 四、接收数据进入==cmdb/urls.py==文件中，编写一个二级路由，将所有++assets相关的数据都转发到assets.urls++中，如下所示：1234567from django.contrib import adminfrom django.conf.urls import url, includeurlpatterns = [ url(&apos;admin/&apos;, admin.site.urls), url(r&apos;^assets/&apos;, include(&apos;assets.urls&apos;)),] 然后，我们在assets中新建一个urls.py文件，写入下面的代码：12345678from django.conf.urls import urlfrom assets import viewsapp_name = &apos;assets&apos;urlpatterns = [ url(r&apos;^report/&apos;, views.report, name=&apos;report&apos;),] 这样，我们的路由就写好了。 转过头，我们进入++assets/views.py++文件，写一个简单的视图。1234567891011from django.shortcuts import render# Create your views here.from django.shortcuts import render, HttpResponsedef report(request): if request.method == &quot;POST&quot;: asset_data = request.POST.get(&apos;asset_data&apos;) print(asset_data) return HttpResponse(&quot;成功收到数据！&quot;) 代码很简单，接收POST过来的数据，打印出来，然后返回成功的消息。 重新运1行python main.py report_data 可以看到： 1234567正在将数据发送至： [http://10.10.7.26:8000/assets/report/] ......handler_data_encode--&gt;&gt; b&apos;asset_data=%7B%22ram%22%3A+%5B%7B%22manufacturer%22%3A+%22802C0...&lt;中间部分省略&gt;...%22%3A+%22Latitude+5480%22%2C+%22sn%22%3A+%2200330-80000-00000-AA069%22%2C+%22os_distribution%22%3A+%22Microsoft%22%2C+%22manufacturer%22%3A+%22Dell+Inc.%22%7D&apos;?[31;1m发送失败，&lt;urlopen error [WinError 10061] 由于目标计算机积极拒绝，无法连接。&gt;?[0m日志记录成功！ 遇到拒绝服务的错误了。 原因在于我们模拟浏览器发送了一个POST请求给Django，但是请求中没有携带Django需要的csrf安全令牌，所以拒绝了请求。 为了解决这个问题，我们需要在这个report视图上忽略csrf验证，可以通过Django的@csrf_exempt装饰器。修改代码如下：1234567891011from django.shortcuts import render, HttpResponsefrom django.views.decorators.csrf import csrf_exempt# Create your views here.@csrf_exemptdef report(request): if request.method == &quot;POST&quot;: asset_data = request.POST.get(&apos;asset_data&apos;) print(asset_data) return HttpResponse(&quot;成功收到数据！&quot;) 重启CMDB服务器，再次从客户端报告数据，可以看到返回结果如下：12345678正在将数据发送至： [http://10.10.7.26:8000/assets/report/] ......handler_data_encode--&gt;&gt; b&apos;asset_data=%7B%22nic%22%3A+%5B%7B%22name%22%3A+1%2C+%22model%22%3A+%22%5B00000001%5D+VMware+Virt...&lt;中间部分省略&gt;...facturer%22%3A+%22802C0000802C%22%2C+%22slot%22%3A+%22DIMM+A%22%2C+%22sn%22%3A+%221B458788%22%2C+%22model%22%3A+%22%5Cu7269%5Cu7406%5Cu5185%5Cu5b58%22%7D%5D%7D&apos;?[31;1m发送完毕！?[0m返回结果：成功收到数据！日志记录成功！ 看下日志记录：1234发送时间：2019-03-03 10:49:26 服务器地址：http://10.10.7.26:8000/assets/report/ 返回结果：发送失败 发送时间：2019-03-03 11:00:53 服务器地址：http://10.10.7.26:8000/assets/report/ 返回结果：发送失败 发送时间：2019-03-03 11:05:36 服务器地址：http://10.10.7.26:8000/assets/report/ 返回结果：发送失败 发送时间：2019-03-03 11:06:51 服务器地址：http://10.10.7.26:8000/assets/report/ 返回结果：成功收到数据！ 这表明数据发送成功了。 再看Pycharm中，也打印出了接收到的数据，一切OK！ CSRF验证的问题解决了，但是又带来新的安全问题。我们可以通过增加用户名、密码，或者md5验证或者自定义安全令牌的方式解决，这部分内容就不展开了。 Windows下的客户端已经验证完毕了，然后我们就可以通过各种方式让脚本定时运行、收集和报告数据，一切都自动化。 最后补充：++CMDB系统是部署在A服务器上，那么客户端CLIENT是需要部署在B服务器上的，那就意味着每台需要被采集数据的服务器都要安装PYTHON及所用到的包。++]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>CMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMDB项目需求分析]]></title>
    <url>%2F2019%2F03%2F02%2F3%E3%80%81%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[CMDB最主要的管理对象：服务器，其数据信息自然不可能通过手工收集，必须以客户端的方式，定时自动收集并报告给远程的服务器。 下面，让我们暂时忘掉Django，进入Python运维的世界…… 一、客户端程序组织编写客户端，不能一个py脚本包打天下，要有组织有目的，通常我们会采取下面的结构： 在Pycharm下，创建一个Client文件夹，作为客户端的根目录。 在Client下，创建上面的包。注意是包，不是文件夹： bin是客户端启动脚本的所在目录 conf是配置文件目录 core是核心代码目录 log是日志文件保存目录 plugins是插件或工具目录 二、开发数据收集客户端1.程序入口脚本++在bin目录中新建main.py文件++，写入下面的代码： 123456789101112131415#!/usr/bin/env python# -*- coding:utf-8 -*-import osimport sysBASE_DIR = os.path.dirname(os.getcwd())# 设置工作目录，使得包和模块能够正常导入sys.path.append(BASE_DIR)from core import handlerif __name__ == &apos;__main__&apos;: handler.ArgvHandler(sys.argv) ##获取参数，传入到ArgvHandler() 通过os和sys模块的配合，将当前客户端所在目录设置为工作目录，如果不这么做，会无法导入其它模块； handler模块是核心代码模块，在core目录中，我们一会来实现它。 以后调用客户端就只需要执行python main.py 参数就可以了 ++这里有个问题一定要强调一下，那就是Python解释器的调用，执行命令的方式和代码第一行#!/usr/bin/env python的指定方式一定不能冲突，要根据你的实际情况实际操作和修改代码，很多新手连Python本身都没搞明白就上来执行脚本，碰到各种解释器不合法的错误，请回去补足基础！++ 2.主功能模块++在core下，创建handler.py文件++，写入下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019-3-2 13:51# @Author : zhdya@zhdya.cn# @File : handler.pyimport jsonimport timeimport urllib.parseimport urllib.requestfrom core import info_collectionfrom conf import settingsclass ArgvHandler(object): def __init__(self, args): self.args = args self.parse_args() def parse_args(self): &quot;&quot;&quot; 分析参数，如果有参数指定的功能，则执行该功能，如果没有，打印帮助说明。 :return: &quot;&quot;&quot; if len(self.args) &gt; 1 and hasattr(self, self.args[1]): func = getattr(self, self.args[1]) func() else: self.help_msg() ##如果执行程序没有带参数就会提示如下信息：help_msg() @staticmethod #静态方法 类或实例均可调用,静态方法函数里不传入self，这样如上self.help_msg()就可以调用了 def help_msg(): &quot;&quot;&quot; 帮助说明 :return: &quot;&quot;&quot; msg = &apos;&apos;&apos; collect_data 收集硬件信息 report_data 收集硬件信息并汇报 &apos;&apos;&apos; print(msg) @staticmethod def collect_data(): &quot;&quot;&quot;收集硬件信息,用于测试！&quot;&quot;&quot; info = info_collection.InfoCollection() asset_data = info.collect() print(asset_data) @staticmethod def report_data(): &quot;&quot;&quot; 收集硬件信息，然后发送到服务器。 :return: &quot;&quot;&quot; # 收集信息 info = info_collection.InfoCollection() asset_data = info.collect() # 将数据打包到一个字典内，并转换为json格式 data = &#123;&quot;asset_data&quot;: json.dumps(asset_data)&#125; print(&quot;handler_data--&gt;&gt;&quot;, data) # 根据settings中的配置，构造url url = &quot;http://%s:%s%s&quot; % (settings.Params[&apos;server&apos;], settings.Params[&apos;port&apos;], settings.Params[&apos;url&apos;]) print(&quot;handler_url--&gt;&gt;&quot;, url) print(&apos;正在将数据发送至： [%s] ......&apos; % url) try: # 使用Python内置的urllib.request库，发送post请求。 # 需要先将数据进行封装，并转换成bytes类型 data_encode = urllib.parse.urlencode(data).encode() print(&quot;handler_data_encode--&gt;&gt;&quot;, data_encode) response = urllib.request.urlopen(url=url, data=data_encode, timeout=settings.Params[&apos;request_timeout&apos;]) print(&quot;\033[31;1m发送完毕！\033[0m &quot;) message = response.read().decode() print(&quot;返回结果：%s&quot; % message) except Exception as e: message = &quot;发送失败&quot; print(&quot;\033[31;1m发送失败，%s\033[0m&quot; % e) # 记录发送日志 with open(settings.PATH, &apos;ab&apos;) as f: ##a追加,b二进制文件 string = &apos;发送时间：%s \t 服务器地址：%s \t 返回结果：%s \n&apos; % (time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;), url, message) f.write(string.encode()) print(&quot;日志记录成功！&quot;) 说明： handler模块中只有一个ArgvHandler类； 在main模块中也是实例化了一个ArgvHandler类的对象，并将调用参数传递进去； 首先，初始化方法会保存调用参数，然后执行parse_args()方法分析参数； 如果ArgvHandler类有参数指定的功能，则执行该功能，如果没有，打印帮助说明。 目前ArgvHandler类只有两个核心方法：collect_data和report_dataa； 这两个方法一个是收集数据并打印到屏幕，用于测试；report_data方法才会将实际的数据发往服务器。 数据的收集由info_collection.InfoCollection类负责，一会再看； report_data方法会将收集到的数据打包到一个字典内，并转换为json格式； 然后通过settings中的配置，构造发送目的地url； 通过Python内置的urllib.parse对数据进行封装； 通过urllib.request将数据发送到目的url； 接收服务器返回的信息； 将成功或者失败的信息写入日志文件中。 以后，我们要测试数据收集，执行：1python main.py collect_data 要实际往服务器发送收集到的数据，则执行：1python main.py report_data 3.配置文件要将所有可能修改的数据、常量、配置等都尽量以配置文件的形式组织起来，尽量不要在代码中写死任何数据。 ++在conf中，新建settings.py文件++，写入下面的代码：12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019-3-2 14:21# @Author : zhdya@zhdya.cn# @File : settings.pyimport os# 远端服务器配置Params = &#123; &quot;server&quot;: &quot;10.10.7.26&quot;, &quot;port&quot;: 8000, &apos;url&apos;: &apos;/assets/report/&apos;, &apos;request_timeout&apos;: 30,&#125;# 日志文件配置PATH = os.path.join(os.path.dirname(os.getcwd()), &apos;log&apos;, &apos;cmdb.log&apos;)print(&quot;conf_settings--&gt;&gt;&quot;, PATH)# 更多配置，请都集中在此文件中 这里，配置了服务器地址、端口、发送的url、请求的超时时间，以及日志文件路径。请根据你的实际情况进行修改。 ==如上server端我是直接启动的django服务 也就是如上10.10.7.26是我笔记本的IP地址，这样默认我笔记本的10.10.7.26:8000就对外开放了！== 4.信息收集模块++在core中新建info_collection.py文件++，写入下面的代码： ==&lt;关于如下：from plugins.linux import sys_info 以及 from plugins.windows import sys_info as win_sys_info 稍后章节我们会建立一系列的目录！！&gt;==1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019-3-2 14:48# @Author : zhdya@zhdya.cn# @File : info_collection.pyimport sysimport platformdef linux_sys_info(): from plugins.linux import sys_info return sys_info.collect()def windows_sys_info(): from plugins.windows import sys_info as win_sys_info return win_sys_info.collect()class InfoCollection(object): def collect(self): # 收集平台信息 # 首先判断当前平台，根据平台的不同，执行不同的方法 try: func = getattr(self, platform.system()) info_data = func() formatted_data = self.build_report_data(info_data) return formatted_data except AttributeError: sys.exit(&quot;不支持当前操作系统： [%s]! &quot; % platform.system()) def Linux(self): return linux_sys_info() def Windows(self): return windows_sys_info() def build_report_data(self, data): # 留下一个接口，方便以后增加功能或者过滤数据 return data 该模块的作用很简单： 首先通过Python内置的platform模块获取执行main脚本的操作系统类别，通常是windows和Linux； 根据操作系统的不同，反射获取相应的信息收集方法，并执行 如果是客户端不支持的操作系统，比如苹果系统，则提示并退出客户端。 因为windows和Linux两大操作系统的巨大平台差异，我们必须写两个收集信息的脚本。 到目前未知，我们的客户端结构如下图所示：]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>CMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMDB项目需求分析]]></title>
    <url>%2F2019%2F03%2F01%2F1%E3%80%81%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、CMDB简介CMDB (Configuration Management Database)配置管理数据库: CMDB用于存储与管理企业IT架构中设备的各种配置信息，它与所有服务支持和服务交付流程都紧密相联，支持这些流程的运转、发挥配置信息的价值，同时依赖于相关流程保证数据的准确性。 CMDB是ITIL(Information Technology Infrastructure Library，信息技术基础架构库)的基础，常常被认为是构建其它ITIL流程的先决条件而优先考虑，ITIL项目的成败与是否成功建立CMDB有非常大的关系。 CMDB的核心是对整个公司的IT硬件/软件资源进行自动/手动收集、变更操作，说白了也就是对IT资产进行自动化管理，这也是本项目的重点。 二、项目需求分析本项目不是一个完整的的CMDB系统，重点针对服务器资产的自动数据收集、报告、接收、审批、更新和展示，搭建一个基础的面向运维的主机管理平台。 下面是项目需求的总结： 尽可能存储所有的IT资产数据，但不包括外设、优盘、显示器这种属于行政部门管理的设备； 硬件信息可自动收集、报告、分析、存储和展示； 具有后台管理人员的工作界面； 具有前端可视化展示的界面； 具有日志记录功能； 数据可手动添加、修改和删除。 当然，实际的CMDB项目需求绝对不止这些，还有诸如用户管理、权限管理、API安全认证、REST设计等等。 三、资产分类资产种类众多，不是所有的都需要CMDB管理，也不是什么都是CMDB能管理的。 下面是一个大致的分类，不一定准确、全面： 资产类型包括： 服务器 存储设备 安全设备 网络设备 软件资产 服务器又可分为： 刀片服务器 PC服务器 小型机 大型机 其它 存储设备包括： 磁盘阵列 网络存储器 磁带库 磁带机 其它 安全设备包括： 防火墙 入侵检测设备 互联网网关 漏洞扫描设备 数字签名设备 上网行为管理设备 运维审计设备 加密机 其它 网络设备包括： 路由器 交换器 负载均衡 VPN 流量分析 其它 软件资产包括： 操作系统授权 大型软件授权 数据库授权 其它 其中，服务器是运维部门最关心的，也是CMDB中最主要、最方便进行自动化管理的资产。 服务器又可以包含下面的部件： CPU 硬盘 内存 网卡 除此之外，我们还要考虑下面的一些内容： 机房 业务线 合同 管理员 审批员 资产标签 其它未尽事宜 大概对资产进行了分类之后，就要详细考虑各细分数据条目了。 共有数据条目： 有一些数据条目是所有资产都应该有的，比如： 资产名称 资产sn 所属业务线 设备状态 制造商 管理IP 所在机房 资产管理员 资产标签 合同 价格 购买日期 过保日期 批准人 批准日期 数据更新日期 备注 另外，不同类型的资产还有各自不同的数据条目，例如服务器： 服务器： 服务器类型 添加方式 宿主机 服务器型号 Raid类型 操作系统类型 发行版本 操作系统版本 其实，在开始正式编写CMDB项目代码之前，对项目的需求分析准确与否，数据条目的安排是否合理，是决定整个CMDB项目成败的关键。这一部分工作看似简单其实复杂，看似无用其实关键，做好了，项目基础就牢固，没做好，推到重来好几遍很正常！]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>CMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMDB项目需求分析]]></title>
    <url>%2F2019%2F03%2F01%2F2%E3%80%81%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[一、创建项目创建Django项目cmdb，配置好settings中的语言和时区，最后新建一个app，名字就叫做assets。这些基本过程以后就不再赘述了，不熟悉的请参考教程的前面部分。 1django版本：1.11.11 创建成功后，初始状态如下图所示： 二、模型设计说明：本项目依然采用SQLite数据库，等下一个项目再使用Mysql。 模型设计是整个项目的重中之重，其它所有的内容其实都是围绕它展开的。 而我们设计数据模型的原则和参考依据是前一节分析的项目需求和数据分类表。 1.资产共有数据模型打开assets/models.py文件，首先我们要设计一张资产表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Asset(models.Model): &quot;&quot;&quot; 所有资产的共有数据表 &quot;&quot;&quot; asset_type_choice = ( (&apos;server&apos;, &apos;服务器&apos;), (&apos;networkdevice&apos;, &apos;网络设备&apos;), (&apos;storagedevice&apos;, &apos;存储设备&apos;), (&apos;securitydevice&apos;, &apos;安全设备&apos;), (&apos;software&apos;, &apos;软件资产&apos;) ) asset_status = ( (0, &apos;在线&apos;), (1, &apos;下线&apos;), (2, &apos;未知&apos;), (3, &apos;故障&apos;), (4, &apos;备用&apos;), ) asset_type = models.CharField(choices=asset_type_choice, max_length=64, default=&apos;server&apos;, verbose_name=&quot;资产类型&quot;) name = models.CharField(max_length=64, unique=True, verbose_name=&quot;资产名称&quot;) ##唯一，不可重复 sn = models.CharField(max_length=128, unique=True, verbose_name=&quot;资产序列号&quot;) ##唯一，不可重复 business_unit = models.ForeignKey(&apos;BusinessUnit&apos;, null=True, blank=True, verbose_name=&quot;所属业务线&quot;) status = models.SmallIntegerField(choices=asset_status, default=0, verbose_name=&quot;设备状态&quot;) manufacturer = models.ForeignKey(&apos;Manufacturer&apos;, null=True, blank=True, verbose_name=&quot;制造商&quot;) manage_ip = models.GenericIPAddressField(null=True, blank=True, verbose_name=&quot;管理IP&quot;) tags = models.ManyToManyField(&apos;Tag&apos;, blank=True, verbose_name=&quot;标签&quot;) admin = models.ForeignKey(User, null=True, blank=True, verbose_name=&quot;资产管理员&quot;, related_name=&apos;admin&apos;) idc = models.ForeignKey(&apos;IDC&apos;, null=True, blank=True, verbose_name=&quot;所在机房&quot;) contract = models.ForeignKey(&apos;Contract&apos;, null=True, blank=True, verbose_name=&quot;合同&quot;) purchase_day = models.DateField(null=True, blank=True, verbose_name=&quot;购买日期&quot;) expire_day = models.DateField(null=True, blank=True, verbose_name=&quot;过保日期&quot;) price = models.FloatField(null=True, blank=True, verbose_name=&quot;价格&quot;) approved_by = models.ForeignKey(User, null=True, blank=True, verbose_name=&quot;批准人&quot;, related_name=&quot;approved_by&quot;) memo = models.TextField(null=True, blank=True, verbose_name=&quot;备注&quot;) c_time = models.DateTimeField(auto_now_add=True, verbose_name=&quot;批准日期&quot;) ##auto_add_now默认=False：储存当对象被创建时的时间，可以用来存储比如说博客什么时候创建的，后来你再更改博客，它的值也不会变。 m_time = models.DateTimeField(auto_now=True, verbose_name=&quot;更新日期&quot;) ##auto_now默认=False:当对象被存储时自动将对象的时间更新为当前时间 def __str__(self): return &apos;&lt;%s&gt; %s&apos; %(self.get_asset_type_display(), self.name) class Meta: verbose_name = &quot;资产总表&quot; verbose_name_plural = &quot;资产总表&quot; ordering = [&apos;-c_time&apos;] 说明： sn这个数据字段是所有资产都必须有，并且唯一不可重复的！通常来自自动收集的数据中； name和sn一样，也是唯一的； asset_type_choice和asset_status分别设计为两个选择类型 admin和approved_by是分别是当前资产的管理员和将该资产上线的审批员； 导入Django内置的User表，作为我们CMDB项目的用户表，用于保存管理员和审判员等人员信息； asset表中的很多字段内容都无法自动获取，需要我们手动输入，比如合同、备注。 2.服务器模型服务器作为资产的一种，而且是最主要的管理对象，包含了一些主要的信息，其模型结构如下：1234567891011121314151617181920212223242526272829class Server(models.Model): &quot;&quot;&quot;服务器设备&quot;&quot;&quot; sub_asset_type_choice = ( (0, &apos;PC服务器&apos;), (1, &apos;刀片型&apos;), (2, &apos;小型机&apos;), ) created_by_choice = ( (&apos;auto&apos;, &apos;自动添加&apos;), (&apos;manual&apos;, &apos;手动录入&apos;), ) asset = models.OneToOneField(&apos;Asset&apos;) # 非常关键的一对一关联！ sub_asset_type = models.SmallIntegerField(choices=sub_asset_type_choice, default=1, verbose_name=&quot;服务器类型&quot;) created_by = models.CharField(choices=created_by_choice, max_length=32, default=&apos;auto&apos;, verbose_name=&quot;添加方式&quot;) hosted_on = models.ForeignKey(&apos;self&apos;, related_name=&apos;hosted_on_server&apos;, blank=True, null=True, verbose_name=&quot;宿主机&quot;) ##虚拟机专用字段 model = models.CharField(max_length=512, blank=True, null=True, verbose_name=&quot;Raid类型&quot;) os_type = models.CharField(&apos;操作系统类型&apos;, max_length=64, blank=True, null=True) os_distribution = models.CharField(&apos;发行版本&apos;, max_length=64, blank=True, null=True) os_release = models.CharField(&apos;操作系统版本&apos;, max_length=64, blank=True, null=True) def __str__(self): return &apos;%s--%s--%s &lt;sn:%s&gt;&apos; %(self.asset.name, self.get_sub_asset_type_display(), self.model, self.asset.sn) class Meta: verbose_name = &apos;服务器&apos; verbose_name_plural = &quot;服务器&quot; 说明： 每台服务器都唯一关联着一个资产对象，因此使用OneToOneField构建了一个一对一字段，这非常重要! 服务器又可分为几种子类型，这里定义了三种； 服务器添加的方式可以分为手动和自动； 有些服务器是虚拟机或者docker生成的，没有物理实体，存在于宿主机中，因此需要增加一个hosted_on字段； 服务器有型号信息，如果硬件信息中不包含，那么指的就是主板型号； Raid类型在采用了Raid的时候才有，否则为空; 操作系统相关信息包含类型、发行版本和具体版本。 3.安全、网络、存储设备和软件资产的模型这部分内容不是项目的主要内容，而且数据大多数不能自动收集和报告，很多都需要手工录入。我这里给出了范例，更多的数据字段，可以自行添加。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class SecurityDevice(models.Model): &quot;&quot;&quot;安全设备&quot;&quot;&quot; sub_asset_type_choice = ( (0, &apos;防火墙&apos;), (1, &apos;入侵检测设备&apos;), (2, &apos;互联网网关&apos;), (4, &apos;运维审计系统&apos;), ) asset = models.OneToOneField(&apos;Asset&apos;) sub_asset_type = models.SmallIntegerField(choices=sub_asset_type_choice, default=0, verbose_name=&quot;安全设备类型&quot;) def __str__(self): return self.asset.name + &quot;--&quot; + self.get_sub_asset_type_display() + &quot; id:%s&quot; % self.id class Meta: verbose_name = &apos;安全设备&apos; verbose_name_plural = &quot;安全设备&quot;class StorageDevice(models.Model): &quot;&quot;&quot;存储设备&quot;&quot;&quot; sub_asset_type_choice = ( (0, &apos;磁盘阵列&apos;), (1, &apos;网络存储器&apos;), (2, &apos;磁带库&apos;), (4, &apos;磁带机&apos;), ) asset = models.OneToOneField(&apos;Asset&apos;) sub_asset_type = models.SmallIntegerField(choices=sub_asset_type_choice, default=0, verbose_name=&quot;存储设备类型&quot;) def __str__(self): return self.asset.name + &quot;--&quot; + self.get_sub_asset_type_display() + &quot; id:%s&quot; % self.id class Meta: verbose_name = &apos;存储设备&apos; verbose_name_plural = &quot;存储设备&quot;class NetworkDevice(models.Model): &quot;&quot;&quot;网络设备&quot;&quot;&quot; sub_asset_type_choice = ( (0, &apos;路由器&apos;), (1, &apos;交换机&apos;), (2, &apos;负载均衡&apos;), (4, &apos;VPN设备&apos;), ) asset = models.OneToOneField(&apos;Asset&apos;) sub_asset_type = models.SmallIntegerField(choices=sub_asset_type_choice, default=0, verbose_name=&quot;网络设备类型&quot;) vlan_ip = models.GenericIPAddressField(blank=True, null=True, verbose_name=&quot;VLanIP&quot;) intranet_ip = models.GenericIPAddressField(blank=True, null=True, verbose_name=&quot;内网IP&quot;) model = models.CharField(max_length=128, null=True, blank=True, verbose_name=&quot;网络设备型号&quot;) firmware = models.CharField(max_length=128, blank=True, null=True, verbose_name=&quot;设备固件版本&quot;) port_num = models.SmallIntegerField(null=True, blank=True, verbose_name=&quot;端口个数&quot;) device_detail = models.TextField(null=True, blank=True, verbose_name=&quot;详细配置&quot;) def __str__(self): return &apos;%s--%s--%s &lt;sn:%s&gt;&apos; % (self.asset.name, self.get_sub_asset_type_display(), self.model, self.asset.sn) class Meta: verbose_name = &apos;网络设备&apos; verbose_name_plural = &quot;网络设备&quot;class Software(models.Model): &quot;&quot;&quot; 只保存付费购买的软件 &quot;&quot;&quot; sub_asset_type_choice = ( (0, &apos;操作系统&apos;), (1, &apos;办公\开发软件&apos;), (2, &apos;业务软件&apos;), ) sub_asset_type = models.SmallIntegerField(choices=sub_asset_type_choice, default=0, verbose_name=&quot;软件类型&quot;) license_num = models.IntegerField(default=1, verbose_name=&quot;授权数量&quot;) version = models.CharField(max_length=64, unique=True, help_text=&apos;例如: CentOS release 6.7 (Final)&apos;, verbose_name=&apos;软件/系统版本&apos;) def __str__(self): return &apos;%s--%s&apos; % (self.get_sub_asset_type_display(), self.version) class Meta: verbose_name = &apos;软件/系统&apos; verbose_name_plural = &quot;软件/系统&quot; 说明： 每台安全、网络、存储设备都通过一对一的方式唯一关联这一个资产对象。 通过sub_asset_type又细分设备的子类型 对于软件，它没有物理形体，因此无须关联一个资产对象； 软件只管理那些大型的收费软件，关注点是授权数量和软件版本。对于那些开源的或者免费的软件，显然不算公司的资产。 4.机房、制造商、业务线、合同、资产标签等数据模型这一部分是CMDB中相关的内容，数据表建立后，可以通过手动添加。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class IDC(models.Model): &quot;&quot;&quot;机房&quot;&quot;&quot; name = models.CharField(max_length=64, unique=True, verbose_name=&quot;机房名称&quot;) memo = models.CharField(max_length=128, blank=True, null=True, verbose_name=&apos;备注&apos;) def __str__(self): return self.name class Meta: verbose_name = &apos;机房&apos; verbose_name_plural = &quot;机房&quot;class Manufacturer(models.Model): &quot;&quot;&quot;厂商&quot;&quot;&quot; name = models.CharField(&apos;厂商名称&apos;, max_length=64, unique=True) telephone = models.CharField(&apos;支持电话&apos;, max_length=30, blank=True, null=True) memo = models.CharField(&apos;备注&apos;, max_length=128, blank=True, null=True) def __str__(self): return self.name class Meta: verbose_name = &apos;厂商&apos; verbose_name_plural = &quot;厂商&quot;class BusinessUnit(models.Model): &quot;&quot;&quot;业务线&quot;&quot;&quot; parent_unit = models.ForeignKey(&apos;self&apos;, blank=True, null=True, related_name=&apos;parent_level&apos;) name = models.CharField(&apos;业务线&apos;, max_length=64, unique=True) memo = models.CharField(&apos;备注&apos;, max_length=64, blank=True, null=True) def __str__(self): return self.name class Meta: verbose_name = &apos;业务线&apos; verbose_name_plural = &quot;业务线&quot;class Contract(models.Model): &quot;&quot;&quot;合同&quot;&quot;&quot; sn = models.CharField(&apos;合同号&apos;, max_length=128, unique=True) name = models.CharField(&apos;合同名称&apos;, max_length=64) memo = models.TextField(&apos;备注&apos;, blank=True, null=True) price = models.IntegerField(&apos;合同金额&apos;) detail = models.TextField(&apos;合同详细&apos;, blank=True, null=True) start_day = models.DateField(&apos;开始日期&apos;, blank=True, null=True) end_day = models.DateField(&apos;失效日期&apos;, blank=True, null=True) license_num = models.IntegerField(&apos;license数量&apos;, blank=True, null=True) c_day = models.DateField(&apos;创建日期&apos;, auto_now_add=True) m_day = models.DateField(&apos;修改日期&apos;, auto_now=True) def __str__(self): return self.name class Meta: verbose_name = &apos;合同&apos; verbose_name_plural = &quot;合同&quot;class Tag(models.Model): &quot;&quot;&quot;标签&quot;&quot;&quot; name = models.CharField(&apos;标签名&apos;, max_length=32, unique=True) c_day = models.DateField(&apos;创建日期&apos;, auto_now_add=True) def __str__(self): return self.name class Meta: verbose_name = &apos;标签&apos; verbose_name_plural = &quot;标签&quot; 说明： 机房可以有很多其它字段，比如城市、楼号、楼层和未知等等，如有需要可自行添加； 业务线可以有子业务线，因此使用一个外键关联自身模型； 合同模型主要存储财务部门关心的数据； 资产标签模型与资产是多对多的关系。 5.CPU模型通常一台服务器中只能有一种CPU型号，所以这里使用OneToOneField唯一关联一个资产对象，而不是外键关系。服务器上可以有多个物理CPU，它们的型号都是一样的。每个物理CPU又可能包含多核。1234567891011121314class CPU(models.Model): &quot;&quot;&quot;CPU组件&quot;&quot;&quot; asset = models.OneToOneField(&apos;Asset&apos;) # 设备上的cpu肯定都是一样的，所以不需要建立多个cpu数据，一条就可以，因此使用一对一。 cpu_model = models.CharField(&apos;CPU型号&apos;, max_length=128, blank=True, null=True) cpu_count = models.PositiveSmallIntegerField(&apos;物理CPU个数&apos;, default=1) cpu_core_count = models.PositiveSmallIntegerField(&apos;CPU核数&apos;, default=1) def __str__(self): return self.asset.name + &quot;: &quot; + self.cpu_model class Meta: verbose_name = &apos;CPU&apos; verbose_name_plural = &quot;CPU&quot; 6.RAM模型某个资产中可能有多条内存，所以这里必须是外键关系。其次，内存的sn号可能无法获得，就必须通过内存所在的插槽未知来唯一确定每条内存。因此，unique_together = (‘asset’, ‘slot’)这条设置非常关键，相当于内存的主键了，每条内存数据必须包含slot字段，否则就不合法。1234567891011121314151617class RAM(models.Model): &quot;&quot;&quot;内存组件&quot;&quot;&quot; asset = models.ForeignKey(&apos;Asset&apos;) # 只能通过外键关联Asset。否则不能同时关联服务器、网络设备等等。 sn = models.CharField(&apos;SN号&apos;, max_length=128, blank=True, null=True) model = models.CharField(&apos;内存型号&apos;, max_length=128, blank=True, null=True) manufacturer = models.CharField(&apos;内存制造商&apos;, max_length=128, blank=True, null=True) slot = models.CharField(&apos;插槽&apos;, max_length=64) capacity = models.IntegerField(&apos;内存大小(GB)&apos;, blank=True, null=True) def __str__(self): return &apos;%s: %s: %s: %s&apos; % (self.asset.name, self.model, self.slot, self.capacity) class Meta: verbose_name = &apos;内存&apos; verbose_name_plural = &quot;内存&quot; unique_together = (&apos;asset&apos;, &apos;slot&apos;) #unique_together，也就是联合唯一，同一资产下的内存，根据插槽slot的不同，必须唯一 7. 硬盘模型与内存相同的是，硬盘也可能有很多块，所以也是外键关系。不同的是，硬盘通常都能获取到sn号，使用sn作为唯一值比较合适，也就是unique_together = (‘asset’, ‘sn’)。硬盘有不同的接口，这里设置了4种以及unknown，可自行添加其它类别。1234567891011121314151617181920212223242526class Disk(models.Model): &quot;&quot;&quot;存储设备&quot;&quot;&quot; disk_interface_type_choice = ( (&apos;SATA&apos;, &apos;SATA&apos;), (&apos;SAS&apos;, &apos;SAS&apos;), (&apos;SCSI&apos;, &apos;SCSI&apos;), (&apos;SSD&apos;, &apos;SSD&apos;), (&apos;unknown&apos;, &apos;unknown&apos;), ) asset = models.ForeignKey(&apos;Asset&apos;) sn = models.CharField(&apos;硬盘SN号&apos;, max_length=128) slot = models.CharField(&apos;所在插槽位&apos;, max_length=64, blank=True, null=True) model = models.CharField(&apos;磁盘型号&apos;, max_length=128, blank=True, null=True) manufacturer = models.CharField(&apos;磁盘制造商&apos;, max_length=128, blank=True, null=True) capacity = models.FloatField(&apos;磁盘容量(GB)&apos;, blank=True, null=True) interface_type = models.CharField(&apos;接口类型&apos;, max_length=16, choices=disk_interface_type_choice, default=&apos;unknown&apos;) def __str__(self): return &apos;%s: %s: %s: %sGB&apos; % (self.asset.name, self.model, self.slot, self.capacity) class Meta: verbose_name = &apos;硬盘&apos; verbose_name_plural = &quot;硬盘&quot; unique_together = (&apos;asset&apos;, &apos;sn&apos;) 8.网卡模型一台设备中可能有很多块网卡，所以网卡与资产也是外键的关系。另外，由于虚拟机的存在，网卡的mac地址可能会发生重复，无法唯一确定某块网卡，因此通过网卡型号加mac地址的方式来唯一确定网卡。123456789101112131415161718class NIC(models.Model): &quot;&quot;&quot;网卡组件&quot;&quot;&quot; asset = models.ForeignKey(&apos;Asset&apos;) # 注意要用外键 name = models.CharField(&apos;网卡名称&apos;, max_length=64, blank=True, null=True) model = models.CharField(&apos;网卡型号&apos;, max_length=128) mac = models.CharField(&apos;MAC地址&apos;, max_length=64) # 虚拟机有可能会出现同样的mac地址 ip_address = models.GenericIPAddressField(&apos;IP地址&apos;, blank=True, null=True) net_mask = models.CharField(&apos;掩码&apos;, max_length=64, blank=True, null=True) bonding = models.CharField(&apos;绑定地址&apos;, max_length=64, blank=True, null=True) def __str__(self): return &apos;%s: %s: %s&apos; % (self.asset.name, self.model, self.mac) class Meta: verbose_name = &apos;网卡&apos; verbose_name_plural = &quot;网卡&quot; unique_together = (&apos;asset&apos;, &apos;model&apos;, &apos;mac&apos;) # 资产、型号和mac必须联合唯一。防止虚拟机中的特殊情况发生错误。 9.日志模型CMDB必须记录各种日志，这是毫无疑问的！我们通常要记录事件名称、类型、关联的资产、子事件、事件详情、谁导致的、发生时间。这些都很重要！ 尤其要注意的是，事件日志不能随着关联资产的删除被一并删除，也就是我们设置on_delete=models.SET_NULL的意义！1234567891011121314151617181920212223242526272829303132class EventLog(models.Model): &quot;&quot;&quot; 日志. 在关联对象被删除的时候，不能一并删除，需保留日志。 因此，on_delete=models.SET_NULL &quot;&quot;&quot; name = models.CharField(&apos;事件名称&apos;, max_length=128) event_type_choice = ( (0, &apos;其它&apos;), (1, &apos;硬件变更&apos;), (2, &apos;新增配件&apos;), (3, &apos;设备下线&apos;), (4, &apos;设备上线&apos;), (5, &apos;定期维护&apos;), (6, &apos;业务上线\更新\变更&apos;), ) asset = models.ForeignKey(&apos;Asset&apos;, blank=True, null=True, on_delete=models.SET_NULL) # 当资产审批成功时有这项数据 new_asset = models.ForeignKey(&apos;NewAssetApprovalZone&apos;, blank=True, null=True, on_delete=models.SET_NULL) # 当资产审批失败时有这项数据 event_type = models.SmallIntegerField(&apos;事件类型&apos;, choices=event_type_choice, default=4) component = models.CharField(&apos;事件子项&apos;, max_length=256, blank=True, null=True) detail = models.TextField(&apos;事件详情&apos;) date = models.DateTimeField(&apos;事件时间&apos;, auto_now_add=True) user = models.ForeignKey(User, blank=True, null=True, verbose_name=&apos;事件执行人&apos;, on_delete=models.SET_NULL) # 自动更新资产数据时没有执行人 memo = models.TextField(&apos;备注&apos;, blank=True, null=True) def __str__(self): return self.name class Meta: verbose_name = &apos;事件纪录&apos; verbose_name_plural = &quot;事件纪录&quot; 10.新资产待审批区模型新资产的到来，并不能直接加入CMDB数据库中，而是要通过管理员审批后，才可以上线的。这就需要一个新资产的待审批区。在该区中，以资产的sn号作为唯一值，确定不同的资产。除了关键的包含资产所有信息的data字段，为了方便审批员查看信息，我们还设计了一些厂商、型号、内存大小、CPU类型等字段。同时，有可能出现资产还未审批，更新数据就已经发过来的情况，所以需要一个数据更新日期字段。1234567891011121314151617181920212223242526272829303132333435363738class NewAssetApprovalZone(models.Model): &quot;&quot;&quot;新资产待审批区&quot;&quot;&quot; sn = models.CharField(&apos;资产SN号&apos;, max_length=128, unique=True) # 此字段必填 asset_type_choice = ( (&apos;server&apos;, &apos;服务器&apos;), (&apos;networkdevice&apos;, &apos;网络设备&apos;), (&apos;storagedevice&apos;, &apos;存储设备&apos;), (&apos;securitydevice&apos;, &apos;安全设备&apos;), (&apos;IDC&apos;, &apos;机房&apos;), (&apos;software&apos;, &apos;软件资产&apos;), ) asset_type = models.CharField(choices=asset_type_choice, default=&apos;server&apos;, max_length=64, blank=True, null=True, verbose_name=&apos;资产类型&apos;) manufacturer = models.CharField(max_length=64, blank=True, null=True, verbose_name=&apos;生产厂商&apos;) model = models.CharField(max_length=128, blank=True, null=True, verbose_name=&apos;型号&apos;) ram_size = models.PositiveIntegerField(blank=True, null=True, verbose_name=&apos;内存大小&apos;) cpu_model = models.CharField(max_length=128, blank=True, null=True, verbose_name=&apos;CPU型号&apos;) cpu_count = models.PositiveSmallIntegerField(blank=True, null=True) cpu_core_count = models.PositiveSmallIntegerField(blank=True, null=True) os_distribution = models.CharField(max_length=64, blank=True, null=True) os_type = models.CharField(max_length=64, blank=True, null=True) os_release = models.CharField(max_length=64, blank=True, null=True) data = models.TextField(&apos;资产数据&apos;) # 此字段必填 c_time = models.DateTimeField(&apos;汇报日期&apos;, auto_now_add=True) m_time = models.DateTimeField(&apos;数据更新日期&apos;, auto_now=True) approved = models.BooleanField(&apos;是否批准&apos;, default=False) def __str__(self): return self.sn class Meta: verbose_name = &apos;新上线待批准资产&apos; verbose_name_plural = &quot;新上线待批准资产&quot; ordering = [&apos;-c_time&apos;] 11.总结通过前面的内容，我们可以看出CMDB数据模型的设计非常复杂，我们这里还是省略了很多不太重要的部分，就这样总共都有400多行代码。其中每个模型需要保存什么字段、采用什么类型、什么关联关系、定义哪些参数、数据是否可以为空，这些都是踩过各种坑后总结出来的，不是随便就能定义的。所以，请务必详细阅读和揣摩这些模型的内容。 一切没有问题之后，注册app，然后makemigrations以及migrate! 注册app： cmdb/settings.py123456789INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;assets&apos;, ##此处] 创建数据库表单：12python manage.py makemigrationspython manage.py migrate]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>CMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django基础学习Ⅰ]]></title>
    <url>%2F2019%2F02%2F11%2FDjango%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%85%A0%2F</url>
    <content type="text"><![CDATA[一、Django简介 Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。 Django是一个处理网络请求的webweb应用框架 Django是开源的 Django有四个核心组件： 1.数据模型和数据库之间的媒介ORM 2.基于正则表达式的URL分发器 3.视图处理系统 4.模板系统 MVC： 12345m modules 模型， 和数据库字段对应v views 视图 用来展示给用户的，就是我们所学到的前端c controll url控制， 一个url，对应一个方法或者类 二、Django特点1) 强大的数据库功能：用python的类继承，几行代码就可以拥有一个动态的数据库操作API，如果需要也能执行SQL语句。2) 自带的强大的后台功能：几行代码就让网站拥有一个强大的后台，轻松管理内容。3) 优雅的网址：用正则匹配网址，传递到对应函数。4) 模板系统：强大，易扩展的模板系统，设计简易，代码和样式分开设计，更易管理。5) 缓存系统：与memcached或其它缓存系统联用，表现更出色，加载速度更快。6) 国际化：完全支持多语言应用，允许你定义翻译的字符，轻松翻译成不同国家的语言 三、安装Django使用pip工具来安装Django，直接通过下面命令来安装就可以。1# pip install Django 用一下测试django是否安装成功：123456C:\Users\ZHDYA&gt;pythonPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import django&gt;&gt;&gt; print (django.VERSION)(2, 0, 6, &apos;final&apos;, 0) 四、创建项目首先，我们先通过django来创建一个项目，命令如下：1# django-admin startproject firstproject 然后在当前目录下就自动生成了一个firstproject的项目然后就可以启动这个项目了：1# python manage.py runserver 127.0.0.1:8080 默认不写ip绑定的是本机的所以ip地址，端口默认为8000 也可以通过在pycharm中直接创建一个Django项目，就自动创建好了文件，然后配置manage.py脚本的参数。 直接再次运行manage.py文件就好。 然后访问url：1http://127.0.0.1:8080 有一个欢迎的首页 4.1、项目目录结构12345678910111213第一层：DjangoTest 项目名称第二层： DjangoTest目录和__init__.py文件，声明是一个包，表示项目实际的python包，不要随意更改该目录，与配置有关联settings.py 项目的全局（所有项目）配置中心urls.py 项目的url配置中心wsgi.py 项目的wsgi配置中心templates 模板目录manage.py django命令管理脚本 setting.py1234567BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) ## 类似于环境变量SECRET_KEY = ##密钥DEBUG = True ##当报错时显示的错误信息ALLOWED_HOSTS = [] ##允许哪些机器可以访问 五、创建app打个比方，jd网站：http://www.jd.com/，上面有各种各样的不同模块，我们划分为不同的app，那我们就需要在django里面创建不通的app啦。接下来，我们就来看看如何创建app如果是命令行模式： 12#python manage.py startapp linux#python manage.py startapp python 如果是pycharm，你就需要点击：1Tools-&gt;&gt;Run manage.py Task 然后出现的交互命令行上输入：1startapp newapp 这样就创建了newapp的app。 六、Django的解析顺序既然我们知道Django是使用的MVC的架构，那我们先来聊聊MVC是什么样的原理，首先，通过MVC中的C就是control，用来接收url请求，对应我们django中的url.py模块，M就代表Model，调用数据库的Model层，就是Django的model.py模块，然后经过业务逻辑层的处理，最后渲染到前端界面。前端就是MVC中的view层，对应django的view模块。 其实所有的参数定义都是以setting.py为准，++首先django先去setting.py中找到ROOT_URLCONF = ‘firstproject.urls’找到总url++。然后在firstproject下的urls.py文件中的urlpatterns列表变量，然后根据里面的URL的正则表达式进行解析，如果解析到，就调用第二个参数，第二个参数对应一个类或者一个函数，或者直接是一个前端页面，在经过类或者函数处理完以后，在展现在前端界面。而前端是单独的html文件，前端界面和后端处理分开，架构更加清晰。 在上面的目录结构中，每一个app都会有一个view.py， model.py，我们自己还要在创建一个url.py，通过include函数，在firstproject项目中的总url.py分出去，把属于各自的app的url分配到不通的APP的urls.py文件中，这样可以降低耦合度，增加代码的健壮性。。 6.1、创建urls.py文件urls作为程序的url入口，支持正则匹配，讲访问的url映射到view中的函数中。为了能调用每个app管理自己的url，我们首先需要在DjangoTest的urls.py文件中做如下修改： 12345678from django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^newapp/&apos;, include(&apos;newapp.urls&apos;)),] 注意事项：为了避免和别的app取同样的名字，一般我们会在名字前加一个app名称作为前缀url匹配，主url不需要/反斜杠：==因为django已经给域名加了一个反斜杠，如：http://127.0.0.1/主url后面要加/， app的url前面就不需要加/了，主url后面一般不要加$符号， app的url后面要加$符号== 然后在创建newapp/urls.py文件，编辑如下： 1234567from django.conf.urls import url, includefrom newapp import viewsurlpatterns = [ url(r&apos;^$&apos;, views.index)] 配置 view.py文件而以上：http://127.0.0.1:8080/newapp的url对应的就是view模块中的index函数，在linux的view.py中定义index函数 1234from django.http import HttpResponsedef index(request): return HttpResponse(&quot;This is a test Django index!!!&quot;) 然后在浏览器上访问：http://127.0.0.1:8080/newapp/，如下图所示： 6.2、如果再次增加内容：urls.py123456789from django.conf.urls import url, includefrom newapp import viewsurlpatterns = [ url(r&quot;^$&quot;, views.index), url(r&apos;newapp/&apos;, views.index), url(r&apos;hello/&apos;, views.hello)] views.py1234567from django.http import HttpResponsedef index(request): return HttpResponse(&quot;This is a test Django index!!!&quot;)def hello(request): return HttpResponse(&quot;&lt;h1 style=&apos;text-align:center&apos;&gt; hheello world!!!&lt;/h1&gt;&quot;) 当访问：http://127.0.0.1:8000/newapp/hello/ 这会出现一个一级标题且居中的字体。 6.3、urls捕获参数（匹配正则表达式）在urls.py中增加如下：1url(r&apos;hello/p1(\w+)p2(.+)/$&apos;, views.hello, name=hello), 在views.py中增加如下：12def hello(request, p1, p2): return HttpResponse(&quot;hello &#123;0&#125;, hello &#123;1&#125;&quot;.format(p1, p2)) url参数的捕获有两种方式：b 捕获关键字参数：在url函数中，正则表达是用（?P）进行捕获，然后在views.py中定义即可 在urls.py中增加如下：1url(r&apos;keyword/(?P&lt;ip&gt;\S+)/$&apos;, views.keyword, name=keyword), 在views.py中增加如下：12def keyword(request, ip): return HttpResponse(&quot;the ip is &#123;0&#125;&quot;.format(ip)) 在浏览器上访问url：http://127.0.0.1:8080/newapp/keyword/1.1.1.1/ 七、urls重定向在学习url重定向之前，我们先来看看定义url的函数是怎样一个表达形式。 注意如下，有个参数 name= 这个是必须要写的，类似于起个别名。1def url(regex, view, kwargs=None, name=None): 1234567regex：url匹配的正则字符串view：一个可以调用的类型函数，或者使用include函数kwargs：关键字参数，必须是一个字典，可以通过这个传递更多参数给views.py，views通过kwargs.get(“key”)得到对应的valuename：给URL取得名字，以后可以通过reverse函数进行重定向 对于kwargs如何传递参数，我们来看一个例子： 在urls.py中增加如下：1url(r&apos;test/$&apos;, view=views.test, kwargs=&#123;&quot;name&quot;: &quot;zhdya&quot;&#125;, name=&quot;test&quot;), 在views.py中增加如下： 12def test(request, **kwargs): return HttpResponse(&quot;the name is : &#123;0&#125;&quot;.format(kwargs.get(&quot;name&quot;))) 在浏览器上访问url：http://127.0.0.1:8080/newapp/test/ 既然已经知道name属性的用法，现在我们就来说重定向，重定向常用name属性来进行重定向 修改urls.py12url(r&quot;^$&quot;, views.index, name=&quot;index&quot;),url(r&quot;redirect/$&quot;, view=views.redirect, name=&quot;redirect&quot;), 修改views.py1234from django.http import HttpResponse, HttpResponseRedirectfrom django.urls import reversedef redirect(request): return HttpResponseRedirect(reverse(&quot;index&quot;)) 在浏览器上访问url：http://127.0.0.1:8080/newapp/redirect，直接跳转到http://127.0.0.1:8080/newapp/， 当然也可以指定返回数据的具体类型，例如：Json格式返回 urls.py1234567891011from django.conf.urls import url, includefrom newapp import viewsurlpatterns = [ url(r&quot;^$&quot;, views.index, name=&quot;index&quot;), # url(r&apos;hello/&apos;, views.hello) url(r&apos;hello/p1(\w+)p2(.+)/$&apos;, views.hello, name=&quot;hello&quot;), url(r&apos;test/$&apos;, view=views.test, kwargs=&#123;&quot;name&quot;: &quot;zhdya&quot;&#125;, name=&quot;test&quot;), url(r&quot;redirect/$&quot;, view=views.redirect, name=&quot;redirect&quot;)] 在views.py中修改主页为：1234567def index(request): test = dict() test[&apos;name&apos;] = &quot;zhdya&quot; test[&apos;sex&apos;] = &quot;man&quot; test[&apos;age&apos;] = 28 # return HttpResponse(&quot;This is a test Django index!!!&quot;) return HttpResponse(json.dumps(test))]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
